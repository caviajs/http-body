import { pascalCase } from '../main/utils/pascal-case';
import { ApiSpec } from '../main/providers/http-server-router';
import { camelCase } from '../main/utils/camel-case';
import { Schema } from '../main/types/schema';

export async function generateHttpClient(apiSpec: ApiSpec): Promise<string> {
  let content: string = '';

  content += `// This file was generated by Cavia, please don't edit it!\n`;
  content += `import { Injectable, HttpClient, HttpResponse } from '@caviajs/core';\n`;
  content += `\n`;
  content += `@Injectable()\n`;
  content += `export class CasHttpClient {\n`;
  content += `\tpublic baseUrl: string = 'http://localhost:3456';\n`;
  content += `\n`;
  content += `\tconstructor(protected readonly httpClient: HttpClient) {\n`;
  content += `\t}\n`;

  for (const endpoint of apiSpec.endpoints) {
    content += `\n`;
    content += `\tpublic async ${ camelCase(endpoint.name) }(\n`;

    if (endpoint.schema?.request?.body) {
      content += `\t\tbody: ${ pascalCase(endpoint.name) }Body,\n`;
    }

    if (endpoint.schema?.request?.headers) {
      content += `\t\theaders: ${ pascalCase(endpoint.name) }Headers,\n`;
    }

    if (endpoint.schema?.request?.params) {
      content += `\t\tparams: ${ pascalCase(endpoint.name) }Params,\n`;
    }

    if (endpoint.schema?.request?.query) {
      content += `\t\tquery: ${ pascalCase(endpoint.name) }Query,\n`;
    }

    content += `\t): Promise<${ pascalCase(endpoint.name) }Response> {\n`;
    content += `\t\tconst url: URL = new URL('${ endpoint.path }', this.baseUrl);\n`;
    content += `\n`;

    if (endpoint.schema?.request?.params) {
      content += `\t\tObject.entries(params || {}).forEach(([key, value]) => {\n`;
      content += '\t\t\turl.pathname = url.pathname.replace(`:${ key }`, value);\n';
      content += `\t\t});\n`;
      content += `\n`;
    }

    if (endpoint.schema?.request?.query) {
      content += '\t\tObject.entries(query || {}).forEach(([key, value]) => {\n';
      content += '\t\t\turl.searchParams.set(key, value);\n';
      content += '\t\t});\n';
      content += `\n`;
    }

    content += '\t\treturn this\n';
    content += '\t\t\t.httpClient\n';
    content += '\t\t\t.request({\n';

    if (endpoint.schema?.request?.body) {
      content += '\t\t\t\tbody: body,\n';
    }

    if (endpoint.schema?.request?.headers) {
      content += '\t\t\t\theaders: headers,\n';
    }

    content += `\t\t\t\tmethod: '${ endpoint.method }',\n`;
    content += `\t\t\t\tresponseType: 'buffer',\n`;
    content += `\t\t\t\t// timeout: undefined,\n`;
    content += `\t\t\t\turl: url.toString(),\n`;

    content += '\t\t\t});\n';

    content += `\t}\n`;
  }

  content += `}\n`;

  for (const endpoint of apiSpec.endpoints) {
    content += `\n`;

    if (endpoint.schema?.request?.body) {
      content += generateTypeBySchema(`${ pascalCase(endpoint.name) }Body`, endpoint.schema?.request?.body);
      content += `\n`;
    }

    if (endpoint.schema?.request?.headers) {
      content += generateTypeBySchema(`${ pascalCase(endpoint.name) }Headers`, endpoint.schema?.request?.headers);
      content += `\n`;
    }

    if (endpoint.schema?.request?.params) {
      content += generateTypeBySchema(`${ pascalCase(endpoint.name) }Params`, endpoint.schema?.request?.params);
      content += `\n`;
    }

    if (endpoint.schema?.request?.query) {
      content += generateTypeBySchema(`${ pascalCase(endpoint.name) }Query`, endpoint.schema?.request?.query);
      content += `\n`;
    }

    content += `export type ${ pascalCase(endpoint.name) }Response = HttpResponse<any>;\n`;
  }

  content += `\n`;

  return content;
}

function generateTypeBySchema(name: string, schema: Schema): string {
  let content: string = '';

  switch (schema.type) {
    case 'array':
      content += `export type ${ pascalCase(name) } = ${ generateTypeStructureBySchema(schema) };\n`;
      break;
    case 'boolean':
      content += `export type ${ pascalCase(name) } = ${ generateTypeStructureBySchema(schema) };\n`;
      break;
    case 'enum':
      content += `export type ${ pascalCase(name) } = ${ generateTypeStructureBySchema(schema) };\n`;
      break;
    case 'number':
      content += `export type ${ pascalCase(name) } = ${ generateTypeStructureBySchema(schema) };\n`;
      break;
    case 'object':
      content += `export type ${ pascalCase(name) } = ${ generateTypeStructureBySchema(schema) };\n`;
      break;
    case 'string':
      content += `export type ${ pascalCase(name) } = ${ generateTypeStructureBySchema(schema) };\n`;
      break;
    default:
      content += `export type ${ pascalCase(name) } = ${ generateTypeStructureBySchema(schema) };\n`;
      break;
  }

  return content;
}

function generateTypeStructureBySchema(schema: Schema): string {
  let content: string = '';

  switch (schema.type) {
    case 'array':
      content += `Array<${ generateTypeStructureBySchema(schema.items) }>`;
      break;
    case 'boolean':
      content += `boolean`;
      break;
    case 'enum':
      Object.values(schema.enum).forEach((value, index) => {
        if (index !== 0) {
          content += ' ';
        }

        if (typeof value === 'string') {
          content += `| '${ value }'`;
        } else if (typeof value === 'number') {
          content += `| ${ value }`;
        } else {
          content += `| unknown`;
        }
      });

      break;
    case 'number':
      content += `number`;
      break;
    case 'object':
      content += '{\n';

      Object.entries(schema.properties || {}).forEach(([key, value]) => {
        content += `\t'${ key }'${ value.required ? '' : '?' }: ${ generateTypeStructureBySchema(value) },\n`;
      });

      content += '}';
      break;
    case 'string':
      content += `string`;
      break;
    default:
      content += `unknown`;
      break;
  }

  if (schema.nullable) {
    content += ' | null';
  }

  return content;
}
