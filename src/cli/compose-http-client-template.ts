import { pascalCase } from '../utils/pascal-case';
import { ApiSpec } from '../http-server/http-router';
import { camelCase } from '../utils/camel-case';
import { Schema } from '../validator/schema';
import { getSchemaNullable, getSchemaRequired, getSchemaStrict } from '../validator/validator';

export function composeHttpClientTemplate(name: string, apiSpec: ApiSpec): string {
  let content: string = '';

  content += `// This file was generated by Cavia, please don't edit it!\n`;
  content += `import { Injectable, HttpClient, HttpResponse } from '@caviajs/core';\n`;
  content += `\n`;
  content += `@Injectable()\n`;
  content += `export class ${ name } {\n`;
  content += `\tpublic baseUrl: string = 'http://localhost:3456';\n`;
  content += `\n`;
  content += `\tconstructor(protected readonly httpClient: HttpClient) {\n`;
  content += `\t}\n`;

  for (const endpoint of apiSpec.endpoints) {
    content += `\n`;
    content += `\tpublic async ${ camelCase(endpoint.name) }(\n`;

    if (endpoint.schema?.request?.body) {
      content += `\t\tbody: ${ pascalCase(endpoint.name) }Body,\n`;
    }

    if (endpoint.schema?.request?.headers) {
      content += `\t\theaders: ${ pascalCase(endpoint.name) }Headers,\n`;
    }

    if (endpoint.schema?.request?.params) {
      content += `\t\tparams: ${ pascalCase(endpoint.name) }Params,\n`;
    }

    if (endpoint.schema?.request?.query) {
      content += `\t\tquery: ${ pascalCase(endpoint.name) }Query,\n`;
    }

    content += `\t): Promise<${ pascalCase(endpoint.name) }Response> {\n`;
    content += `\t\tconst url: URL = new URL('${ endpoint.path }', this.baseUrl);\n`;
    content += `\n`;

    if (endpoint.schema?.request?.params) {
      content += `\t\tObject.entries(params || {}).forEach(([key, value]) => {\n`;
      content += '\t\t\turl.pathname = url.pathname.replace(`:${ key }`, value);\n';
      content += `\t\t});\n`;
      content += `\n`;
    }

    if (endpoint.schema?.request?.query) {
      content += '\t\tObject.entries(query || {}).forEach(([key, value]) => {\n';
      content += '\t\t\turl.searchParams.set(key, value);\n';
      content += '\t\t});\n';
      content += `\n`;
    }

    content += '\t\treturn this\n';
    content += '\t\t\t.httpClient\n';
    content += '\t\t\t.request({\n';

    if (endpoint.schema?.request?.body) {
      content += '\t\t\t\tbody: body,\n';
    }

    if (endpoint.schema?.request?.headers) {
      content += '\t\t\t\theaders: headers,\n';
    }

    content += `\t\t\t\tmethod: '${ endpoint.method }',\n`;
    content += `\t\t\t\tresponseType: 'buffer',\n`;
    content += `\t\t\t\t// timeout: undefined,\n`;
    content += `\t\t\t\turl: url.toString(),\n`;

    content += '\t\t\t});\n';

    content += `\t}\n`;
  }

  content += `}\n`;

  for (const endpoint of apiSpec.endpoints) {
    content += `\n`;

    if (endpoint.schema?.request?.body) {
      content += generateTypeBySchema(`${ pascalCase(endpoint.name) }Body`, endpoint.schema?.request?.body);
      content += `\n`;
    }

    if (endpoint.schema?.request?.headers) {
      content += generateTypeBySchema(`${ pascalCase(endpoint.name) }Headers`, endpoint.schema?.request?.headers);
      content += `\n`;
    }

    if (endpoint.schema?.request?.params) {
      content += generateTypeBySchema(`${ pascalCase(endpoint.name) }Params`, endpoint.schema?.request?.params);
      content += `\n`;
    }

    if (endpoint.schema?.request?.query) {
      content += generateTypeBySchema(`${ pascalCase(endpoint.name) }Query`, endpoint.schema?.request?.query);
      content += `\n`;
    }

    if (endpoint.schema?.responses) {
      content += `export type ${ pascalCase(endpoint.name) }Response =\n`;

      Object.entries(endpoint.schema?.responses || {}).forEach(([status, response], index, array) => {
        content += `\t| ${ pascalCase(endpoint.name) }Response${ status }${ index === array.length - 1 ? ';' : '' }\n`;
      });

      for (const [status, response] of Object.entries(endpoint.schema?.responses || {})) {
        content += `\n`;
        content += `export interface ${ pascalCase(endpoint.name) }Response${ status } extends HttpResponse {\n`;
        content += `\tbody: ${ pascalCase(endpoint.name) }Response${ status }Body,\n`;
        content += `\theaders: ${ pascalCase(endpoint.name) }Response${ status }Headers,\n`;
        content += `\tstatusCode: ${ status },\n`;
        content += `\tstatusMessage: string,\n`;
        content += `}\n`;

        content += `\n`;
        content += generateTypeBySchema(`${ pascalCase(endpoint.name) }Response${ status }Body`, response.body);

        content += `\n`;
        content += generateTypeBySchema(`${ pascalCase(endpoint.name) }Response${ status }Headers`, response.headers);
      }
    } else {
      content += `export type ${ pascalCase(endpoint.name) }Response = HttpResponse;\n`;
    }
  }

  content += `\n`;

  return content;
}

function generateTypeBySchema(name: string, schema: Schema): string {
  let content: string = '';

  switch (schema?.type) {
    case 'array':
      content += `export type ${ pascalCase(name) } = ${ generateTypeStructureBySchema(schema) };\n`;
      break;
    case 'boolean':
      content += `export type ${ pascalCase(name) } = ${ generateTypeStructureBySchema(schema) };\n`;
      break;
    case 'enum':
      content += `export type ${ pascalCase(name) } = ${ generateTypeStructureBySchema(schema) };\n`;
      break;
    case 'number':
      content += `export type ${ pascalCase(name) } = ${ generateTypeStructureBySchema(schema) };\n`;
      break;
    case 'object':
      content += `export type ${ pascalCase(name) } = ${ generateTypeStructureBySchema(schema) };\n`;
      break;
    case 'string':
      content += `export type ${ pascalCase(name) } = ${ generateTypeStructureBySchema(schema) };\n`;
      break;
    default:
      content += `export type ${ pascalCase(name) } = ${ generateTypeStructureBySchema(schema) };\n`;
      break;
  }

  return content;
}

function generateTypeStructureBySchema(schema: Schema): string {
  const isNullable: boolean = schema ? getSchemaNullable(schema) : false;
  const isRequired: boolean = schema ? getSchemaRequired(schema) : false;

  let content: string = '';

  switch (schema?.type) {
    case 'array':
      content += `Array<${ generateTypeStructureBySchema(schema.items) }>`;
      break;
    case 'boolean':
      content += `boolean`;
      break;
    case 'enum':
      Object.values(schema.enum).forEach((value, index) => {
        if (index !== 0) {
          content += ' ';
        }

        if (typeof value === 'string') {
          content += `| '${ value }'`;
        } else if (typeof value === 'number') {
          content += `| ${ value }`;
        } else {
          content += `| unknown`;
        }
      });

      break;
    case 'number':
      content += `number`;
      break;
    case 'object':
      const isStrict: boolean = getSchemaStrict(schema);

      content += '{\n';

      Object.entries(schema.properties || {}).forEach(([key, value]) => {
        content += `\t'${ key }'${ isRequired === true ? '' : '?' }: ${ generateTypeStructureBySchema(value) },\n`;
      });

      if (isStrict === false) {
        content += `\t[name: string]: any,\n`;
      }

      content += '}';
      break;
    case 'string':
      content += `string`;
      break;
    default:
      content += `any`;
      break;
  }

  if (isNullable === true) {
    content += ' | null';
  }

  return content;
}
